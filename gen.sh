#!/bin/bash

# Script to generate the-code-is-self-documented project structure
set -e

echo "Generating the-code-is-self-documented project structure..."

# Create project directories
mkdir -p cmd/tcisd
mkdir -p internal/commands
mkdir -p internal/config
mkdir -p internal/logic
mkdir -p internal/processor
mkdir -p pkg/matcher
mkdir -p pkg/remover

# Create main.go
cat > main.go << 'EOL'
// Command tcisd provides a tool for stripping comments from code files.
//
// Usage:
//
//	# Lint files for comments
//	tcisd lint [flags] [path ...]
//
//	# Remove comments from files
//	tcisd format [flags] [path ...]
package main

import (
	"fmt"
	"os"

	"github.com/idelchi/tcisd/internal/logic"
)

// Global variable for CI stamping.
var version = "unknown - unofficial & generated by unknown"

func main() {
	exitCode := logic.Run(version)
	os.Exit(exitCode)
}
EOL

# Create cmd/tcisd/main.go
cat > cmd/tcisd/main.go << 'EOL'
package main

import (
	"os"

	"github.com/idelchi/tcisd/internal/logic"
)

// Global variable for CI stamping.
var version = "unknown - unofficial & generated by unknown"

func main() {
	exitCode := logic.Run(version)
	os.Exit(exitCode)
}
EOL

# Create internal/commands/root.go
cat > internal/commands/root.go << 'EOL'
package commands

import (
	"github.com/spf13/cobra"

	"github.com/idelchi/tcisd/internal/config"
	"github.com/idelchi/tcisd/pkg/cobraext"
)

// NewRootCommand creates the root command with common configuration.
// It sets up environment variable binding and flag handling.
func NewRootCommand(cfg *config.Config, version string) *cobra.Command {
	root := cobraext.NewDefaultRootCommand(version)

	root.Use = "tcisd [flags] command [flags]"
	root.Short = "Strip comments from code files"
	root.Long = "tcisd is a tool for stripping comments from code files.\n" +
		"It can verify if files have comments (lint mode) or remove them (format mode)."

	root.Flags().BoolP("show", "s", false, "Show the configuration and exit")
	root.AddCommand(NewLintCommand(cfg), NewFormatCommand(cfg))

	return root
}
EOL

# Create internal/commands/lint.go
cat > internal/commands/lint.go << 'EOL'
package commands

import (
	"fmt"

	"github.com/spf13/cobra"

	"github.com/idelchi/tcisd/internal/config"
	"github.com/idelchi/tcisd/pkg/cobraext"
)

// NewLintCommand creates the lint subcommand.
// It handles checking files for comments without modifying them.
func NewLintCommand(cfg *config.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "lint [flags] [path ...]",
		Short: "Check files for comments",
		Long:  "Check files for comments without modifying them.",
		Args:  cobra.ArbitraryArgs,
		PreRunE: func(_ *cobra.Command, args []string) error {
			if len(args) == 0 {
				return fmt.Errorf("at least one path must be provided")
			}

			cfg.Paths = args
			cfg.Mode = config.LintMode

			return cobraext.Validate(cfg, cfg)
		},
		RunE: func(_ *cobra.Command, _ []string) error {
			return nil // Processing happens in the parent logic
		},
	}

	cmd.Flags().StringArrayP("pattern", "p", []string{"**/*.go"}, "File pattern to match (doublestar format)")
	cmd.Flags().StringArrayP("type", "t", []string{"go"}, "File types to process (go, bash, python)")
	cmd.Flags().StringArrayP("exclude", "e", nil, "Patterns to exclude")
	cmd.Flags().BoolP("hidden", "a", false, "Include hidden files and directories")

	// Bind flags to config
	cobraext.MustBindPFlags(cmd, cfg)

	return cmd
}
EOL

# Create internal/commands/format.go
cat > internal/commands/format.go << 'EOL'
package commands

import (
	"fmt"

	"github.com/spf13/cobra"

	"github.com/idelchi/tcisd/internal/config"
	"github.com/idelchi/tcisd/pkg/cobraext"
)

// NewFormatCommand creates the format subcommand.
// It handles stripping comments from files.
func NewFormatCommand(cfg *config.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "format [flags] [path ...]",
		Short: "Strip comments from files",
		Long:  "Strip comments from files, modifying them in-place.",
		Args:  cobra.ArbitraryArgs,
		PreRunE: func(_ *cobra.Command, args []string) error {
			if len(args) == 0 {
				return fmt.Errorf("at least one path must be provided")
			}

			cfg.Paths = args
			cfg.Mode = config.FormatMode

			return cobraext.Validate(cfg, cfg)
		},
		RunE: func(_ *cobra.Command, _ []string) error {
			return nil // Processing happens in the parent logic
		},
	}

	cmd.Flags().StringArrayP("pattern", "p", []string{"**/*.go"}, "File pattern to match (doublestar format)")
	cmd.Flags().StringArrayP("type", "t", []string{"go"}, "File types to process (go, bash, python)")
	cmd.Flags().StringArrayP("exclude", "e", nil, "Patterns to exclude")
	cmd.Flags().BoolP("hidden", "a", false, "Include hidden files and directories")
	cmd.Flags().BoolP("dry-run", "d", false, "Show what would be changed without modifying files")

	// Bind flags to config
	cobraext.MustBindPFlags(cmd, cfg)

	return cmd
}
EOL

# Create internal/config/config.go
cat > internal/config/config.go << 'EOL'
package config

import (
	"errors"
	"fmt"
)

// Mode represents the operation mode of the application.
type Mode string

const (
	// LintMode checks files for comments without modifying them.
	LintMode Mode = "lint"
	// FormatMode strips comments from files.
	FormatMode Mode = "format"
)

// ErrUsage indicates an error in command-line usage or configuration.
var ErrUsage = errors.New("usage error")

// Config holds the application's configuration parameters.
type Config struct {
	// Show enables output display
	Show bool

	// Mode is the operation mode (lint or format)
	Mode Mode

	// Patterns is a list of file patterns to match
	Patterns []string `mapstructure:"pattern"`

	// Types is a list of file types to process
	Types []string `mapstructure:"type"`

	// Exclude is a list of patterns to exclude
	Exclude []string

	// Hidden indicates whether to include hidden files
	Hidden bool

	// DryRun indicates whether to show changes without modifying files
	DryRun bool `mapstructure:"dry-run"`

	// Paths is a list of paths to process
	Paths []string
}

// Display returns the value of the Show field.
func (c Config) Display() bool {
	return c.Show
}

// Validate performs configuration validation.
// It returns a wrapped ErrUsage if any validation rules are violated.
func (c Config) Validate() error {
	if len(c.Patterns) == 0 {
		return fmt.Errorf("%w: at least one pattern must be provided", ErrUsage)
	}

	if len(c.Types) == 0 {
		return fmt.Errorf("%w: at least one file type must be provided", ErrUsage)
	}

	// Validate file types
	validTypes := map[string]bool{
		"go":     true,
		"bash":   true,
		"python": true,
	}

	for _, t := range c.Types {
		if !validTypes[t] {
			return fmt.Errorf("%w: invalid file type: %s", ErrUsage, t)
		}
	}

	if len(c.Paths) == 0 {
		return fmt.Errorf("%w: at least one path must be provided", ErrUsage)
	}

	return nil
}
EOL

# Create internal/logic/logic.go
cat > internal/logic/logic.go << 'EOL'
package logic

import (
	"fmt"
	"log"
	"os"
	"runtime"

	"github.com/fatih/color"

	"github.com/idelchi/tcisd/internal/commands"
	"github.com/idelchi/tcisd/internal/config"
	"github.com/idelchi/tcisd/internal/processor"
	"github.com/idelchi/tcisd/pkg/cobraext"
)

// Run is the main function of the application.
func Run(version string) int {
	// Create the Config instance
	cfg := &config.Config{}
	root := commands.NewRootCommand(cfg, version)

	// Execute the root command
	switch err := root.Execute(); {
	case errors.Is(err, cobraext.ErrExitGracefully):
		return 0
	case err != nil:
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		return 1
	}

	// Set up processor with appropriate number of workers
	proc := processor.New(
		cfg,
		min(runtime.NumCPU(), len(cfg.Paths)),
		cfg.Types,
	)

	// Process the files
	if err := proc.Process(); err != nil {
		fmt.Fprintf(os.Stderr, "%s: %v\n", color.RedString("Error"), err)
		return 1
	}

	// Print summary
	hasIssues := proc.Summary()

	if hasIssues && cfg.Mode == config.LintMode {
		log.Println(color.RedString("Comments found in files"))
		return 1
	}

	if !hasIssues {
		log.Println(color.GreenString("No comments found in files"))
	}

	return 0
}
EOL

# Create internal/processor/processor.go
cat > internal/processor/processor.go << 'EOL'
package processor

import (
	"fmt"
	"log"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
	"github.com/natefinch/atomic"

	"github.com/idelchi/tcisd/internal/config"
	"github.com/idelchi/tcisd/pkg/matcher"
	"github.com/idelchi/tcisd/pkg/remover"
)

// Processor handles the processing of files.
type Processor struct {
	cfg *config.Config
	// Number of workers
	workers int
	// File types to process
	types []string
	// Files to process
	files []string
	// Results from processing
	results map[string][]string
	// Processing time
	processingTime time.Duration
}

// New creates a new processor.
func New(cfg *config.Config, workers int, types []string) *Processor {
	return &Processor{
		cfg:      cfg,
		workers:  workers,
		types:    types,
		results:  make(map[string][]string),
	}
}

// Process handles the processing of files.
func (p *Processor) Process() error {
	// Find matching files
	m := matcher.New(p.cfg.Hidden, p.cfg.Exclude, log.New(os.Stderr, "", 0))

	for _, path := range p.cfg.Paths {
		for _, pattern := range p.cfg.Patterns {
			fullPattern := fmt.Sprintf("%s/%s", path, pattern)
			if err := m.Match(fullPattern); err != nil {
				return fmt.Errorf("matching pattern %s: %w", fullPattern, err)
			}
		}
	}

	p.files = m.ListFiles()

	if len(p.files) == 0 {
		return fmt.Errorf("no files found")
	}

	log.Printf("Found %d files to process", len(p.files))

	// Process files with workers
	start := time.Now()

	// Create a buffered channel to hold jobs
	jobs := make(chan string, len(p.files))

	// Create a channel to receive results
	results := make(chan struct {
		file   string
		issues []string
	}, len(p.files))

	// Create a wait group to wait for all workers to finish
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < p.workers; i++ {
		wg.Add(1)
		go p.worker(i, jobs, results, &wg)
	}

	// Send jobs to workers
	for _, file := range p.files {
		jobs <- file
	}
	close(jobs)

	// Wait for all workers to finish
	wg.Wait()
	close(results)

	// Collect results
	for result := range results {
		if len(result.issues) > 0 {
			p.results[result.file] = result.issues
		}
	}

	p.processingTime = time.Since(start)

	return nil
}

// worker processes files.
func (p *Processor) worker(id int, jobs <-chan string, results chan<- struct {
	file   string
	issues []string
}, wg *sync.WaitGroup) {
	defer wg.Done()

	for file := range jobs {
		log.Printf("Processing file: %s", file)

		// Determine file type based on extension
		fileType := detectFileType(file)

		// Skip file if its type is not in the list of types to process
		if !contains(p.types, fileType) {
			continue
		}

		// Read file
		content, err := os.ReadFile(file)
		if err != nil {
			log.Printf("Error reading file %s: %v", file, err)
			continue
		}

		// Get the appropriate remover
		r := remover.ForType(fileType)
		if r == nil {
			log.Printf("No remover found for file type %s", fileType)
			continue
		}

		// Process content
		lines := strings.Split(string(content), "\n")
		processedLines, issues := r.Process(lines)

		// If in format mode and there are issues, write the processed content back to the file
		if p.cfg.Mode == config.FormatMode && len(issues) > 0 && !p.cfg.DryRun {
			if err := atomic.WriteFile(file, strings.NewReader(strings.Join(processedLines, "\n"))); err != nil {
				log.Printf("Error writing file %s: %v", file, err)
			}
		}

		results <- struct {
			file   string
			issues []string
		}{file, issues}
	}
}

// Summary prints a summary of the processing results.
func (p *Processor) Summary() bool {
	log.Printf("Processed %d files in %s", len(p.files), p.processingTime)

	hasIssues := len(p.results) > 0

	if hasIssues {
		log.Printf("Found comments in %d files:", len(p.results))

		for file, issues := range p.results {
			log.Printf("  %s:", color.YellowString(file))
			for _, issue := range issues {
				log.Printf("    - %s", issue)
			}
		}

		if p.cfg.Mode == config.FormatMode {
			if p.cfg.DryRun {
				log.Println(color.YellowString("Dry run: no files were modified"))
			} else {
				log.Println(color.GreenString("Files were modified successfully"))
			}
		}
	}

	return hasIssues
}

// detectFileType determines the file type based on extension.
func detectFileType(file string) string {
	ext := strings.ToLower(strings.TrimPrefix(strings.LastIndex(file, "."), "."))

	switch ext {
	case "go":
		return "go"
	case "sh", "bash":
		return "bash"
	case "py", "python":
		return "python"
	default:
		return ext
	}
}

// contains checks if a string is in a slice.
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if s == str {
			return true
		}
	}
	return false
}
EOL

# Create pkg/matcher/matcher.go
cat > pkg/matcher/matcher.go << 'EOL'
package matcher

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"

	"github.com/bmatcuk/doublestar/v4"
)

// Logger is an interface for logging formatted messages.
type Logger interface {
	Printf(format string, v ...interface{})
}

// Matcher is a file matcher that compiles a list of files matching a given pattern.
type Matcher struct {
	// Exclude is a list of patterns that are used to exclude files.
	Exclude []string
	// Logger is a logger for debug messages.
	Logger Logger
	// files is the list of files that are added to the matcher.
	files []string
	// Additional file exclusion functions
	extraExcludes map[string]func(string) bool
}

// ListFiles returns all files found by the Matcher.
func (m *Matcher) ListFiles() []string {
	if m.files == nil {
		return []string{}
	}

	return m.files
}

// New creates a Matcher with default settings.
func New(hidden bool, exclude []string, logger Logger) Matcher {
	matcher := Matcher{
		Exclude: exclude,
		Logger:  logger,
	}

	// Get the name of the executable itself
	if exe, err := os.Executable(); err == nil {
		// Exclude the executable itself
		matcher.Exclude = append(matcher.Exclude, exe)
	}

	matcher.Exclude = append(matcher.Exclude,
		// Exclude all kinds of executables
		"**/*.exe",

		// Exclude some known directories
		"**/.git/**",
		"**/node_modules/**",
		"**/vendor/**",
		"**/.task/**",
		"**/.cache/**",
	)

	if !hidden {
		// Exclude hidden folders & files if hidden is false
		matcher.Exclude = append(matcher.Exclude, "**/.*", "**/.*/**/*")
	}

	matcher.extraExcludes = map[string]func(string) bool{
		"binary file": IsBinary,
	}

	return matcher
}

// Match finds all files matching the given pattern and applies the exclusion options.
func (m *Matcher) Match(pattern string) (err error) {
	// Get all files that match the pattern
	var matches []string

	if matches, err = doublestar.FilepathGlob(pattern, doublestar.WithFilesOnly()); err != nil {
		return fmt.Errorf("matching pattern %q: %w", pattern, err)
	}

outer:
	for _, match := range matches {
		// Convert to absolute path
		match, _ = filepath.Abs(match)
		match = filepath.ToSlash(match)

		switch {
		// Skip files that are already found
		case contains(match, m.files):
			m.Logger.Printf("Skipped %q: already in matches", match)
		// If the file is explicitly included, include it immediately
		case IsExplicitlyIncluded(pattern):
			m.Logger.Printf("Including %q: explicitly included", match)
			m.files = append(m.files, match)
		case IsExcluded(match, m.Exclude) != "":
			m.Logger.Printf("Skipped %q: matches exclude pattern %q", match, IsExcluded(match, m.Exclude))
		default:
			for name, fn := range m.extraExcludes {
				if fn(match) {
					m.Logger.Printf("Skipped %q: %s", match, name)
					continue outer
				}
			}
			// Append the match to the matches slice
			m.files = append(m.files, match)
		}
	}

	return nil
}

// IsBinary checks if a file is binary.
func IsBinary(file string) bool {
	// Simple binary detection by reading the first 512 bytes
	f, err := os.Open(file)
	if err != nil {
		return false
	}
	defer f.Close()

	buf := make([]byte, 512)
	n, err := f.Read(buf)
	if err != nil {
		return false
	}

	// Check for null bytes in the first 512 bytes
	for i := 0; i < n; i++ {
		if buf[i] == 0 {
			return true
		}
	}

	return false
}

// IsExplicitlyIncluded returns true if the given pattern is considered to be explicitly included.
func IsExplicitlyIncluded(pattern string) bool {
	return !strings.Contains(pattern, "*")
}

// IsExcluded returns the exclude pattern that the given file matches, or an empty string if none.
func IsExcluded(file string, excludes []string) string {
	for _, pattern := range excludes {
		if matched, _ := doublestar.Match(pattern, file); matched {
			return pattern
		}
	}
	return ""
}

// contains checks if a string is in a slice of strings.
func contains(str string, slice []string) bool {
	return slices.Contains(slice, str)
}
EOL

# Create pkg/remover/remover.go
cat > pkg/remover/remover.go << 'EOL'
package remover

// Remover defines the interface for comment removal.
type Remover interface {
	// Process removes comments from the given lines of code.
	// It returns the processed lines and a list of issues found.
	Process(lines []string) ([]string, []string)
}

// registry of removers by file type
var registry = map[string]Remover{
	"go":     &GoRemover{},
	"bash":   &BashRemover{},
	"python": &PythonRemover{},
}

// ForType returns a Remover for the given file type.
func ForType(fileType string) Remover {
	return registry[fileType]
}

// Register adds a remover to the registry.
func Register(fileType string, remover Remover) {
	registry[fileType] = remover
}
EOL

# Create pkg/remover/go.go
cat > pkg/remover/go.go << 'EOL'
package remover

import (
	"fmt"
	"regexp"
	"strings"
)

// GoRemover implements Remover for Go source files.
type GoRemover struct{}

// Process removes comments from Go code.
func (r *GoRemover) Process(lines []string) ([]string, []string) {
	result := make([]string, len(lines))
	copy(result, lines)

	issues := []string{}

	// Handle multi-line comments
	inMultiLineComment := false
	multiLineStart := 0

	// Regular expression for single-line comments
	singleLineRe := regexp.MustCompile(`(^|[^:])//.*$`)

	// Process each line
	for i, line := range result {
		// Skip empty lines
		if strings.TrimSpace(line) == "" {
			continue
		}

		// Handle multi-line comments
		if inMultiLineComment {
			if strings.Contains(line, "*/") {
				// End of multi-line comment found
				endIndex := strings.Index(line, "*/") + 2
				result[i] = strings.TrimSpace(line[endIndex:])
				inMultiLineComment = false

				issues = append(issues, fmt.Sprintf("Multi-line comment from line %d to %d", multiLineStart+1, i+1))
			} else {
				// Still in multi-line comment
				result[i] = ""
			}
			continue
		}

		// Check for start of multi-line comment
		if strings.Contains(line, "/*") {
			startIndex := strings.Index(line, "/*")

			// Check if there's also an end of multi-line comment on the same line
			if strings.Contains(line[startIndex:], "*/") {
				// Both start and end on the same line
				endIndex := startIndex + strings.Index(line[startIndex:], "*/") + 2
				beforeComment := line[:startIndex]
				afterComment := line[endIndex:]
				result[i] = strings.TrimSpace(beforeComment + afterComment)

				issues = append(issues, fmt.Sprintf("Multi-line comment on line %d", i+1))
			} else {
				// Start of multi-line comment
				result[i] = strings.TrimSpace(line[:startIndex])
				inMultiLineComment = true
				multiLineStart = i
			}
		} else {
			// Handle single-line comments
			if singleLineRe.MatchString(line) {
				beforeComment := singleLineRe.ReplaceAllString(line, "$1")
				result[i] = strings.TrimSpace(beforeComment)

				issues = append(issues, fmt.Sprintf("Single-line comment on line %d", i+1))
			}
		}
	}

	return result, issues
}
EOL

# Create pkg/remover/bash.go
cat > pkg/remover/bash.go << 'EOL'
package remover

import (
	"fmt"
	"strings"
)

// BashRemover implements Remover for Bash scripts.
type BashRemover struct{}

// Process removes comments from Bash scripts.
func (r *BashRemover) Process(lines []string) ([]string, []string) {
	result := make([]string, len(lines))
	copy(result, lines)

	issues := []string{}

	for i, line := range result {
		// Skip empty lines
		if strings.TrimSpace(line) == "" {
			continue
		}

		// Preserve shebang
		if i == 0 && strings.HasPrefix(line, "#!") {
			continue
		}

		// Handle comments
		if strings.Contains(line, "#") {
			commentIndex := strings.Index(line, "#")

			// Make sure it's not inside a string
			inSingleQuotes := false
			inDoubleQuotes := false
			isComment := true

			for j := 0; j < commentIndex; j++ {
				char := line[j]
				if char == '\'' && !inDoubleQuotes {
					inSingleQuotes = !inSingleQuotes
				} else if char == '"' && !inSingleQuotes {
					inDoubleQuotes = !inDoubleQuotes
				}
			}

			// If we're inside quotes, it's not a comment
			if inSingleQuotes || inDoubleQuotes {
				isComment = false
			}

			if isComment {
				result[i] = strings.TrimSpace(line[:commentIndex])
				issues = append(issues, fmt.Sprintf("Comment on line %d", i+1))
			}
		}
	}

	return result, issues
}
EOL

# Create pkg/remover/python.go
cat > pkg/remover/python.go << 'EOL'
package remover

import (
	"fmt"
	"regexp"
	"strings"
)

// PythonRemover implements Remover for Python source files.
type PythonRemover struct{}

// Process removes comments from Python code.
func (r *PythonRemover) Process(lines []string) ([]string, []string) {
	result := make([]string, len(lines))
	copy(result, lines)

	issues := []string{}

	// Handle multi-line docstrings
	inMultiLineDocstring := false
	docstringStart := 0
	docstringType := ""

	// Regular expression for single-line comments
	singleLineRe := regexp.MustCompile(`(^|[^"'])#.*$`)

	// Process each line
	for i, line := range result {
		// Skip empty lines
		if strings.TrimSpace(line) == "" {
			continue
		}

		// Handle multi-line docstrings
		if inMultiLineDocstring {
			if strings.Contains(line, docstringType) {
				// End of docstring found
				endIndex := strings.Index(line, docstringType) + len(docstringType)
				result[i] = strings.TrimSpace(line[endIndex:])
				inMultiLineDocstring = false

				issues = append(issues, fmt.Sprintf("Docstring from line %d to %d", docstringStart+1, i+1))
			} else {
				// Still in docstring
				result[i] = ""
			}
			continue
		}

		// Check for start of triple-quoted docstrings
		if strings.Contains(line, "\"\"\"") && !inMultiLineDocstring {
			startIndex := strings.Index(line, "\"\"\"")

			// Check if there's also an end on the same line
			if strings.Count(line, "\"\"\"") >= 2 {
				// Both start and end on the same line
				endIndex := startIndex + 3 + strings.Index(line[startIndex+3:], "\"\"\"") + 3
				beforeComment := line[:startIndex]
				afterComment := line[endIndex:]
				result[i] = strings.TrimSpace(beforeComment + afterComment)

				issues = append(issues, fmt.Sprintf("Docstring on line %d", i+1))
			} else {
				// Start of docstring
				result[i] = strings.TrimSpace(line[:startIndex])
				inMultiLineDocstring = true
				docstringStart = i
				docstringType = "\"\"\""
			}
		} else if strings.Contains(line, "'''") && !inMultiLineDocstring {
			startIndex := strings.Index(line, "'''")

            // Check if there's also an end on the same line
            if strings.Count(line, "'''") >= 2 {
                // Both start and end on the same line
                endIndex := startIndex + 3 + strings.Index(line[startIndex+3:], "'''") + 3
                beforeComment := line[:startIndex]
                afterComment := line[endIndex:]
                result[i] = strings.TrimSpace(beforeComment + afterComment)

                issues = append(issues, fmt.Sprintf("Docstring on line %d", i+1))
            } else {
                // Start of docstring
                result[i] = strings.TrimSpace(line[:startIndex])
                inMultiLineDocstring = true
                docstringStart = i
                docstringType = "'''"
            }
        } else {
            // Handle single-line comments
            if singleLineRe.MatchString(line) {
                beforeComment := singleLineRe.ReplaceAllString(line, "$1")
                result[i] = strings.TrimSpace(beforeComment)

                issues = append(issues, fmt.Sprintf("Single-line comment on line %d", i+1))
            }
        }
    }

    return result, issues
}
EOL

mkdir -p pkg/cobraext
# Create pkg/cobraext/cobraext.go
cat > pkg/cobraext/cobraext.go << 'EOL'
package cobraext

import (
	"errors"
	"fmt"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/idelchi/godyl/pkg/pretty"
)

// ErrExitGracefully is an error that signals the program to exit gracefully.
var ErrExitGracefully = errors.New("exit")

// Validator is an interface for types that can show and validate their configuration.
type Validator interface {
	Validate() error
	Display() bool
}

// NewDefaultRootCommand creates a root command with default settings.
// It sets up integration with viper, with environment variable and flag binding.
func NewDefaultRootCommand(version string) *cobra.Command {
	root := &cobra.Command{
		Version:       version,
		SilenceUsage:  true,
		SilenceErrors: true,
	}

	root.CompletionOptions.DisableDefaultCmd = true
	root.Flags().SortFlags = false

	root.SetVersionTemplate("{{ .Version }}\n")

	return root
}

// MustBindPFlags binds a command's flags to viper.
// It panics if it encounters an error.
func MustBindPFlags(cmd *cobra.Command, cfg interface{}) {
	if err := viper.BindPFlags(cmd.Flags()); err != nil {
		panic(fmt.Sprintf("binding flags: %v", err))
	}
}

// Validate unmarshals the configuration and performs validation checks.
// If cfg.Show is true, prints the configuration and exits.
func Validate(cfg Validator, validations ...interface{}) error {
	if err := viper.Unmarshal(cfg); err != nil {
		return fmt.Errorf("unmarshalling config: %w", err)
	}

	if cfg.Display() {
		pretty.PrintJSONMasked(cfg)
		return ErrExitGracefully
	}

	if err := cfg.Validate(); err != nil {
		return fmt.Errorf("validating config: %w", err)
	}

	return nil
}
EOL

# Create pkg/cobraext/pipe_or_arg.go
cat > pkg/cobraext/pipe_or_arg.go << 'EOL'
package cobraext

import (
	"fmt"
	"io"
	"os"
	"strings"
)

// PipeOrArg reads from either the first argument or stdin.
// If an argument is provided, it is returned.
// If no argument is provided but stdin is piped, the stdin content is returned.
// If neither an argument nor stdin is provided, an empty string is returned.
func PipeOrArg(args []string) (string, error) {
	if len(args) > 0 {
		// Prioritize argument if it exists, regardless of stdin
		return args[0], nil
	}

	if IsPiped() {
		// No arg but stdin is piped
		arg, err := Read()
		if err != nil {
			return "", fmt.Errorf("reading from stdin: %w", err)
		}

		return arg, nil
	}

	return "", nil
}

// IsPiped checks if something has been piped to stdin.
func IsPiped() bool {
	fi, err := os.Stdin.Stat()
	return (fi.Mode()&os.ModeCharDevice) == 0 && err == nil
}

// Read returns stdin as a string, trimming the trailing newline.
func Read() (string, error) {
	bytes, err := io.ReadAll(os.Stdin)
	return strings.TrimSuffix(string(bytes), "\n"), err
}
EOL

# Create go.mod
cat > go.mod << 'EOL'
module github.com/idelchi/tcisd

go 1.21

require (
	github.com/bmatcuk/doublestar/v4 v4.6.0
	github.com/fatih/color v1.15.0
	github.com/idelchi/godyl v0.0.0-20241029091045-af98851a0cee
	github.com/natefinch/atomic v1.0.1
	github.com/spf13/cobra v1.8.0
	github.com/spf13/viper v1.18.2
)

require (
	github.com/fsnotify/fsnotify v1.7.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.17 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/pelletier/go-toml/v2 v2.1.0 // indirect
	github.com/sagikazarmark/locafero v0.4.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/showa-93/go-mask v0.6.2 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.11.0 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.9.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/sys v0.15.0 // indirect
	golang.org/x/text v0.14.0 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
EOL

echo "Project structure generated successfully!"
echo "To use the tool, run:"
echo "cd the-code-is-self-documented"
echo "go mod tidy"
echo "go build"
echo "# Lint files for comments:"
echo "./the-code-is-self-documented lint --pattern=\"**/*.go\" path/to/files"
echo "# Remove comments from files:"
echo "./the-code-is-self-documented format --pattern=\"**/*.go\" path/to/files"
